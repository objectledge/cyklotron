/*
 * Created on 2003-11-13
 */
package net.cyklotron.cms.search.internal;

import java.util.Date;
import java.util.StringTokenizer;

import net.cyklotron.cms.CmsTool;
import net.cyklotron.cms.UserData;
import net.cyklotron.cms.category.CategoryService;
import net.cyklotron.cms.integration.IntegrationService;
import net.cyklotron.cms.integration.ResourceClassResource;
import net.cyklotron.cms.search.IndexableResource;
import net.cyklotron.cms.search.IndexingFacility;
import net.cyklotron.cms.search.SearchConstants;
import net.cyklotron.cms.search.SearchUtil;
import net.labeo.services.ServiceBroker;
import net.labeo.services.resource.Resource;
import net.labeo.services.resource.Subject;
import net.labeo.services.resource.generic.NodeResource;

import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;

/**
 * Constructs lucene documents from Indexable resources. 
 *
 * @author <a href="mailto:dgajda@caltha.pl">Damian Gajda</a>
 * @version $Id: DocumentConstructor.java,v 1.1 2005-01-12 20:44:34 pablo Exp $
 */
public class DocumentConstructor
{
	private ServiceBroker broker;

	/** integeration service */
	private IntegrationService integrationService;
    
	/** category service */
	private CategoryService categoryService; 

    /**
     * 
     */
    public DocumentConstructor(ServiceBroker broker)
    {
    	this.broker = broker;
    	
		integrationService = (IntegrationService)broker.getService(IntegrationService.SERVICE_NAME);
		categoryService = (CategoryService)broker.getService(CategoryService.SERVICE_NAME);
    }

	/**
	 * Create a lucene document from an given indexable resource.
	 *
	 * <p>Obligatory fields:</p>
	 * <ul>
	 * <li>index_title - IST - Text</li>
	 * <li>index_abbreviation - IST - Text</li>
	 * <li>index_content - IT - UnStored</li>
	 * </ul>
	 *
	 * <p>Technical (autogenerated) fields:</p>
	 * <ul>
	 * <li>id - IS - Keyword</li>
	 * <li>modification_time - IS - Keyword</li>
	 * <li>path - I</li>
	 * <li>site_name - IS - Keyword</li>
     * <li>branch_id - S - Keyword -
     *      <strong>WARN:</strong> added only by use of {@link #setBranchField(Resource)}</li>
	 * <li>resource_class_id - IS - Keyword</li>
	 * </ul>
	 *
	 * <p>Legend:</p>
	 * <ul>
	 * <li>I - indexed</li>
	 * <li>S - stored</li>
	 * <li>T - tokenized</li>
	 * </ul>
	 *
	 * @param node the indexable resource.
	 * @return the lucene document or <code>null</code> if all the document fields were empty.
	 */
	public Document createDocument(IndexableResource node)
	{
		Document doc = new Document();

		boolean documentEmpty = true;
		String tmp;

		// obligatory
		tmp = node.getIndexTitle();
		if (tmp != null)
		{
			doc.add(Field.Text(SearchConstants.FIELD_INDEX_TITLE, tmp));
			documentEmpty = false;
		}
		tmp = node.getIndexAbbreviation();
		if (tmp != null)
		{
			doc.add(Field.Text(SearchConstants.FIELD_INDEX_ABBREVIATION, tmp));
			documentEmpty = false;
		}
		tmp = node.getIndexContent();
		if (tmp != null)
		{
			doc.add(Field.UnStored(SearchConstants.FIELD_INDEX_CONTENT, tmp));
			documentEmpty = false;
		}

		ResourceClassResource rcr = integrationService.getResourceClass(node.getResourceClass());
		String indexableFields = rcr.getIndexableFields();
		if(indexableFields != null)
		{
			StringTokenizer st = new StringTokenizer(indexableFields);
			while(st.hasMoreTokens())
			{
				String fieldName = st.nextToken();
				Object value = node.getFieldValue(fieldName);
                String strValue = getValueAsIndexableString(value);                     
				if(strValue != null)
				{
					boolean store = node.isStored(fieldName);
					boolean index = node.isIndexed(fieldName);
					boolean token = node.isTokenized(fieldName);
					doc.add(new Field(fieldName, strValue, store, index, token));
					documentEmpty = false;
				}
			}
		}
                
		if (!documentEmpty)
		{
			// technical
			doc.add(Field.Keyword(SearchConstants.FIELD_ID, node.getIdString()));
			doc.add(Field.Keyword(SearchConstants.FIELD_MODIFICATION_TIME, SearchUtil.dateToString(node.getModificationTime())));
			doc.add(new Field(SearchConstants.FIELD_PATH, node.getPath(), false, true, false));
			doc.add(Field.Keyword(SearchConstants.FIELD_SITE_NAME, CmsTool.getSite(node).getName()));
			doc.add(Field.Keyword(SearchConstants.FIELD_RESOURCE_CLASS_ID, node.getResourceClass().getIdString()));

            if(node instanceof NodeResource)
            {
                if(((NodeResource)node).getDescription() != null)
                {
                    doc.add(Field.UnStored(SearchConstants.FIELD_DESCRIPTION, ((NodeResource)node).getDescription()));
                }
            }

            String ownerLogin = getValueAsIndexableString(node.getOwner());
            if(ownerLogin != null)
            {
                doc.add(Field.UnStored(SearchConstants.FIELD_OWNER, ownerLogin));
            }
            
			StringBuffer sb = new StringBuffer();
			Resource[] categories = categoryService.getCategories(node, false);
			for(int i = 0; i < categories.length; i++)
			{
				if(i > 0)
				{
					sb.append('\n');
				}
				sb.append(categories[i].getPath());
			}
			// we don't want to store category information
			doc.add(Field.UnStored(SearchConstants.FIELD_CATEGORY, sb.toString()));
			return doc;
		}
		else
		{
			return null;
		}
	}

    public void setBranchField(Document doc, Resource branch)
    {
        if(doc != null)
        {
            doc.removeFields(SearchConstants.FIELD_BRANCH_ID);
            doc.add(Field.Keyword(SearchConstants.FIELD_BRANCH_ID, branch.getIdString()));
        }
    }

    /**
     * Create a lucene document from an given indexable resource and set branch field in it.
     * 
     * @return the lucene document or <code>null</code> if all the document fields were empty.
     */
    public Document createDocument(IndexableResource node, Resource branch)
    {
        Document doc = createDocument(node);
        setBranchField(doc, branch);
        return doc;
    }


	// implementation //////////////////////////////////////////////////////////////////////////////
	
	private String getValueAsIndexableString(Object value)
	{
		if(value == null)
		{
			return null;
		}
		
		String str = null;
		if(value instanceof String)
		{
			str = (String)value;
		}
		else
		if(value instanceof Date)
		{
			str = SearchUtil.dateToString((Date)value);
		}
		else
		if(value instanceof Subject)
		{
			UserData userData = new UserData(broker, (Subject)value);
			try
			{
				str = userData.getLogin();
			}
			catch (Exception e)
			{
				return null;
			}
		}
		else
		if(value instanceof Integer)
		{
			str = ((Integer)value).toString();
		}
		else
		if(value instanceof Long)
		{
			str = ((Long)value).toString();
		}
		else
		if(value instanceof Double)
		{
			str = ((Double)value).toString();
		}
		else
		if(value instanceof Float)
		{
			str = ((Float)value).toString();
		}
		// TODO add support for other non string values (ie - daterange)
		/*else
		if(value instanceof DateRange)
		{
			attributeValue = ((DateRange)value).;
		}*/
		return str;
	}	
}
